### Subject: Recommendations for Improving Your Matching and Ranking System

This document outlines a series of enhancements to optimize your Firestore queries and improve the relevance of your matching algorithm without adding major new services.

---

### Section 1: Optimizing Database Queries (High-Impact)

The most critical bottleneck is fetching all documents from the `posts` collection in your `fetchEnhancedMatches` function. We can drastically reduce document reads by applying filters directly in Firestore.

**Recommendation 1.1: Pre-filter by Type and Budget**

Instead of fetching everything, construct a Firestore query to filter by `type` and `price`. This is a fundamental first step.

**Example Implementation (`src/lib/matching.ts`):**

```typescript
// BEFORE
const snap = await db.collection("posts").get();

// AFTER
let query: admin.firestore.Query = db.collection("posts")
  .where('type', '==', filterType)
  .where('price', '>=', filters.budgetMin)
  .where('price', '<=', filters.budgetMax);

const snap = await query.get();
```

*Note: Firestore requires an index for this compound query. The Firestore console will provide a link to create it automatically the first time the query fails.*

**Recommendation 1.2: Implement Geohash-based Location Filtering**

Firestore does not support native geospatial radius queries. The standard workaround is to use geohashes.

1.  **Add a `geohash` field** to your `posts` documents. When a post is created or its address is updated, calculate its geohash (e.g., using a library like `ngeohash`).
2.  **Query a range of geohashes.** In your `fetchEnhancedMatches` function, calculate the geohash for the user's search center and the geohashes that cover the desired radius. You can then use a Firestore range query (`.where('geohash', '>=', start_hash).where('geohash', '<=', end_hash)`) to fetch only posts within that geographic area. This drastically reduces the number of documents you have to process for distance calculations.

---

### Section 2: Enhancing the Ranking Algorithm

Once you have a smaller, more relevant set of documents, you can apply a more sophisticated ranking.

**Recommendation 2.1: Add a Recency Boost**

Newer listings are often more desirable. Add a gentle scoring boost to more recent posts.

**Example Logic:**

```typescript
const now = new Date().getTime();
const postAgeInDays = (now - post.createdAt.getTime()) / (1000 * 3600 * 24);
const recencyScore = Math.max(0, 1 - (postAgeInDays / 30)); // Score from 1 (today) to 0 (30+ days ago)

// Then, factor it into the combined score:
const combined = (semScore * 0.6) + (sScore * 0.3) + (recencyScore * 0.1);
```

**Recommendation 2.2: Implement Hybrid Keyword + Semantic Scoring**

Combine the power of semantic search with explicit keyword matching for more intuitive results.

**Example Logic:**

1.  Pass the user's original search keywords to the matching function.
2.  Calculate a keyword score based on matches with the post's `keywords` array.
3.  Combine this with the semantic and structured scores.

```typescript
// In fetchEnhancedMatches
const userKeywords = ["pet-friendly", "balcony"]; // Example user keywords
const postKeywords = post.keywords || [];
const keywordMatches = userKeywords.filter(k => postKeywords.includes(k)).length;
const keywordScore = (keywordMatches / userKeywords.length) || 0;

// Adjust combined score weighting
const combined = (semScore * 0.5) + (sScore * 0.3) + (keywordScore * 0.15) + (recencyScore * 0.05);
```

**Recommendation 2.3: Use Graded Scoring Instead of Harsh Penalties**

Instead of multiplying the score by `0.5` for a mismatch in bedrooms/bathrooms, use a graded approach that penalizes listings less for being "close enough."

**Example Logic:**

```typescript
// Instead of: if (post.structured.bedrooms !== filters.bedrooms) sScore *= 0.5;

const bedDiff = Math.abs(post.structured.bedrooms - filters.bedrooms);
sScore *= (1 - bedDiff * 0.2); // e.g., 1 bed diff -> 0.8x, 2 bed diff -> 0.6x
```

---

### Section 3: System & UX Enhancements

**Recommendation 3.1: Improve Match Explanations**

Provide more context to the user about why a result was ranked highly.

**Example Logic:**

```typescript
let explanation = [];
if (semScore > 0.4) explanation.push("Matches your description well.");
if (keywordScore > 0.5) explanation.push("Contains your keywords.");
if (sScore > 0.8) explanation.push("Fits your filters.");
if (recencyScore > 0.9) explanation.push("Posted recently.");

// post.explanation = explanation.join(' ');
```

This approach will make your application significantly more performant and your search results more relevant to your users. 